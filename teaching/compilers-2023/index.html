<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Balagopal Komarath" />
  <title>
Compilers (2023)
</title>
  <link rel="stylesheet" type="text/css" href="/css/bk.css" />
</head>
<body>
  <header>
  <a class="skip-link" aria-label="Skip to main content" href="#main">Skip to main content</a>
  <a class="logo" href="/index.html">bkomarath</a>
  <nav aria-label="Primary navigation">
    <ul>
      <li>
        <a
          role="button"
          href=""
          tabindex="0"
        >
          Main
        </a>
        <ul>
          <li><a href="/research">Research</a></li>
          <li><a href="/teaching">Teaching</a></li>
          <li><a href="/posts">Writing</a></li>
          <li><a href="/cv">CV</a></li>
        </ul>
      </li>
    </ul>
  </nav>
</header>

  
<main>
  <h1>Compilers (2023)</h1>
  <p>Welcome to CS327: Compilers. In this course, we will design and implement a compiler for a simple imperative language. We will aim for the following language features.</p>
<ul>
<li>Basic Types: numbers, booleans, strings.</li>
<li>Compound Types: products, sums, arrays.</li>
<li>Conditionals.</li>
<li>Loops.</li>
<li>Functions.</li>
<li>Closures.</li>
<li>Mutable variables.</li>
<li>Exceptions.</li>
</ul>
<p>We will aim to implement a tree-walking interpreter followed by designing a bytecode along with a source to bytecode compiler that implements some optimizations such as function inlining, loop unrolling, constant folding, and dead code elimination.</p>
<p>My code for this course will be hosted at the <a href="https://github.com/balu/sim">github repository for CS327: Compilers (2023)</a>.</p>
<h2 id="current-status">Current status</h2>
<p>I list here the chapters from the text book that covers the topics we have discussed.</p>
<p>Chapters 4, 5, 6, 7, 8, 9, and some parts of 11.</p>
<h2 id="project">Project</h2>
<p>This section lists the goals of the project. Everyone should try to complete the minimal (M) goals. The goals marked intermediate (I) and advanced (A) can be taken up once the minimal goals are achieved.</p>
<ul>
<li>M: A number type and arithmetic.</li>
<li>I: Multiple number types such as fractions and integers. Quotient and division are different. Quotient has type (integer, integer) -&gt; integer and division has type (fraction, fraction) -&gt; fraction. An integer can be used wherever a fraction can be used.</li>
<li>M: Let expressions.</li>
<li>I: Parallel <code>let</code> (See <code>let..and</code> in Ocaml).</li>
<li>M: A Boolean type, comparisons, and if-else.</li>
<li>I: An explicit unary boolifying operator. In Perl <code>so x</code> where <code>x</code> has any type produces a Boolean value. For example, if <code>x</code> is a number, it is true when non-zero. If <code>x</code> is a string, it is true when non-empty.</li>
<li>M: Mutable variables.</li>
<li>I: Static type checking. The expression <code>(5&gt;3) + 2</code> should be an error without evaluating anything.</li>
<li>A: Disallow mutable variables to change type. With the binding <code>let mut p = True in ...</code>, the variable <code>p</code> should only be assigned boolean values.</li>
<li>M: Strings with concatenation and slicing.</li>
<li>M: A <code>print</code> operation that prints values to screen.</li>
<li>M: loops.</li>
<li>M: Functions</li>
<li>M: Lists with operations <code>cons</code>, <code>is-empty?</code>, <code>head</code>, <code>tail</code>.</li>
<li>I: <code>for</code> loop to iterate over lists.</li>
<li>I: Mutable arrays with indexing, appending, popping, concatenation, element assignment.</li>
<li>I: Allow declaration of type of array. For example <code>let xs: Array[int] = [] in ...</code> should prevent <code>xs[0] ‚Üê 5/3</code>.</li>
<li>A: Step-by-step debugger for your programming language.</li>
<li>A: User-defined types &ndash; records.</li>
<li>A: First-class functions.</li>
</ul>
<h2 id="meetings">Meetings</h2>
<h3 id="17-03-2023">17-03-2023</h3>
<p>Bytecode generation for conditionals and loops.</p>
<h3 id="15-03-2023">15-03-2023</h3>
<p>Stack VM, Bytecode generation for arithmetic expressions.</p>
<h3 id="03-03-2023">03-03-2023</h3>
<p>Importance of formalizing passes. Parser generators (GNU Bison, Python parsimonious). Programming language shootout game. Code golf.</p>
<h3 id="01-03-2023">01-03-2023</h3>
<p>Arrays vs Lists performance. Implementing arrays. Referential transparency. Copy-on-Write.</p>
<p>First-class functions and closures. Using heap to implement closures.</p>
<h3 id="24-02-2023">24-02-2023</h3>
<p>Implementing variable resolution for proper behaviour.</p>
<h3 id="22-02-2023">22-02-2023</h3>
<p>Pitfalls of Python style extreme late binding of symbols.</p>
<h3 id="15-02-2023">15-02-2023</h3>
<p>Implementing function definitions and function calls.</p>
<h3 id="13-02-2023">13-02-2023</h3>
<p>Exam I sheets loaned. Discussed project evaluation.</p>
<h3 id="10-02-2023">10-02-2023</h3>
<p>We discussed name visibility of functions in various languages. Late binding in Python, forward declarations in C, and explicit syntactic form for mutual recursion in OCaml.</p>
<h3 id="04-02-2023">04-02-2023</h3>
<p>Exam I.</p>
<h3 id="03-02-2023">03-02-2023</h3>
<p>We implemented an imperative environment that handles scoping of mutable variables.</p>
<h3 id="01-02-2023">01-02-2023</h3>
<p>We discussed how to write environments for handling mutable variables correctly.</p>
<h3 id="27-01-2023">27-01-2023</h3>
<p>We discussed operator precedence, associativity, and how to write a grammar that captures these concepts. We then saw how one can write a parser for such grammars.</p>
<h3 id="25-01-2023">25-01-2023</h3>
<p>We discussed parsing. Recursive descent parsing peeks at the first token and determines how to parse the string based on that. We discussed ambiguity in expression parsing and how recursive descent fails for arithmetic expressions in infix form.</p>
<h3 id="20-01-2023">20-01-2023</h3>
<p>We discussed lexing where we produce a stream of tokens from a stream of characters (also known as source code).</p>
<h3 id="18-01-2023">18-01-2023</h3>
<p>We discussed static analysis &ndash; analysis of programs without evaluating them. A part of it is semantic analysis which involves type checking. We discussed how to perform typechecking by tree-walking. We discussed language design choices such as expression+statements or expression-only languages and statically-typed vs dynamically-typed languages.</p>
<h3 id="16-01-2023">16-01-2023</h3>
<p>We discussed project submission workflow. All individual contributions SHOULD be associated with their github (or equivalent) id. As a rough guideline for project goals, try to implement solutions for the first five questions from <a href="https://projecteuler.net/">Project Euler</a> in the language you are implementing.</p>
<h3 id="13-01-2023">13-01-2023</h3>
<p>We implemented <code>let</code> expressions in our interpreter by keeping track of environments that map names into values.</p>
<h3 id="11-01-2023">11-01-2023</h3>
<p>We learned lexical scoping and <code>let</code> bindings that introduce lexically scoped bindings.</p>
<h3 id="09-01-2023">09-01-2023</h3>
<p>We wrote code for an arithmetic expression tree evaluator. We discussed internal representation of programs &ndash; Abstract Syntax Trees (ASTs). We then defined an AST suitable for a calculator in Python and wrote a tree-walk <code>eval()</code> for it.</p>
<h3 id="04-01-2023">04-01-2023</h3>
<p>Attendance is not mandatory. Grading will be divided into theory exams (50) and team project (50). There will be three assessments for both and the split will be (15 + 15 + 20). Each team may have four to five members including a team leader. You can choose any programming language. The history of the project should be tracked via git and commits should identify contribution. Before assessment, each team has to submit information regarding work done by each member. This will be compared against git commits and performance in TA evaluations. Theory exams will mostly be subjective and will test your understanding of concepts.</p>
<p>You can learn about <a href="https://docs.github.com/en/get-started/quickstart/hello-world">using git via this github tutorial</a>. Each team member should have their own fork of their project where they make their commits. Individual changes can be pushed to a main repository that will aggregate all contributions into the group&rsquo;s output.</p>
<p><a href="https://docs.python.org/3/library/dataclasses.html">Python dataclasses</a>, <a href="https://peps.python.org/pep-0636/">Python match statement</a>, and <a href="https://pypi.org/project/pytest/">pytest</a> will be extensively used by me during lectures. For your project, feel free to use your preferred tools.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://craftinginterpreters.com/">Robert Nystrom&rsquo;s excellent book</a></li>
<li><a href="https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages">Wikibook on PLs</a></li>
<li><a href="https://rosettacode.org/wiki/Rosetta_Code">Rosetta code for sample programs in various languages</a></li>
<li><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">Programming language benchmarks comparing performance of various languages</a></li>
<li><a href="https://projecteuler.net/">Project Euler for simple programs to test your language</a></li>
</ul>

</main>

  <footer>
  <p>
    All content on this website is licensed under
    <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA
      4.0</a> by Balagopal Komarath unless mentioned otherwise.
</footer>

<script>
 'use strict';

 class DisclosureNav {
   constructor(navNode) {
     this.navNode = navNode;
     var menus = navNode.querySelectorAll('a[role="button"]');
     this.menus = [];
     for (var i = 0; i < menus.length; ++i) {
       this.menus.push(new DisclosureMenu(menus[i]));
     }
     this.navNode.addEventListener(
       'focusout',
       this.onFocusOut.bind(this)
     );
   }

   onFocusOut(event) {
     var containsFocus = this.navNode.contains(event.relatedTarget);
     

     if (event.relatedTarget && !containsFocus) {
       this.menus.forEach((menu) => {
         menu.close();
       });
     }
   }
 }

 var nextID = 0;

 function generateID() {
   return ++nextID;
 }

 class DisclosureMenu {
   constructor(menuNode) {
     this.id = '_nav_menu_' + generateID();
     this.menuNode = menuNode;
     this.controlledMenu = menuNode.parentNode.querySelector('ul');
     this.controlledMenuItems = this.controlledMenu.querySelectorAll('li');

      
     this.menuNode.classList.add("disclosure-menu-closed");
     this.menuNode.setAttribute("aria-expanded", "false");
     this.menuNode.setAttribute("aria-haspopup", "true");
     this.menuNode.setAttribute("aria-controls", this.id);

      
     this.controlledMenu.classList.add("disclosure-toggled-list-closed");
     this.controlledMenu.setAttribute("id", this.id);

     menuNode.addEventListener(
       'click',
       this.onClick.bind(this)
     );
     menuNode.addEventListener(
       'keydown',
       this.onMenuKeyDown.bind(this)
     );
     for (var i = 0; i < this.controlledMenuItems.length; ++i) {
       var menuItem = this.controlledMenuItems[i];
       menuItem.addEventListener(
         'keydown',
         this.onMenuItemKeyDown.bind(this)
       );
     }
   }

   isClosed() {
     return this.menuNode.classList.contains("disclosure-menu-closed");
   }

   onClick(event) {
     event.preventDefault();
     this.toggleMenu(this.isClosed());
   }

   close() { this.toggleMenu(false); }

   open() { this.toggleMenu(true); }

   toggleMenu(should_open) {
     var closed = this.isClosed();

     if (should_open && !closed) return;
     if (!should_open && closed) return;

     if (should_open) {
       this.menuNode.classList.replace(
         "disclosure-menu-closed",
         "disclosure-menu-opened"
       );
       this.menuNode.setAttribute("aria-expanded", "true");
       this.controlledMenu.classList.replace("disclosure-toggled-list-closed", "disclosure-toggled-list-opened");
     } else {
       this.menuNode.classList.replace("disclosure-menu-opened", "disclosure-menu-closed");
       this.menuNode.setAttribute("aria-expanded", "false");
       this.controlledMenu.classList.replace("disclosure-toggled-list-opened", "disclosure-toggled-list-closed");
     }
   }

   onMenuKeyDown(event) {
     if (event.key === " ") {
       event.preventDefault();
       this.toggleMenu(this.isClosed());
     } else if (event.key === 'Escape') {
       this.close();
     }
   }

   onMenuItemKeyDown(event) {
     if (event.key === 'Escape') {
       this.toggleMenu(false);
       this.menuNode.focus();
     }
   }
 }

 function initNavigation(navs) {
   for (let nav of navs) {
     new DisclosureNav(nav);
   }
 }

 window.addEventListener(
   'load',
   function () {
     var navMenus = document.querySelectorAll('nav a[role="button"]');
     var navs = [];
     for (var i = 0; i < navMenus.length; ++i) {
       var nav = navMenus[i].parentNode.parentNode;
       if (!navs.find((otherNav) => otherNav === nav)) {
         navs.push(nav);
       }
     }
     initNavigation(navs);
   },
   false
 );

</script>

</body>
</html>
